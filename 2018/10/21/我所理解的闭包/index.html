<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="zlkBlog" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="zlkBlog" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="zlkBlog" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="JavaScript"><link rel="canonical" href="http://example.com/2018/10/21/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AD%E5%8C%85/"><title>我所理解的闭包 - 转载 | Garden Hamster = zlkBlog = Stay Hungry, Stay Foolish</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">我所理解的闭包</h1><div class="meta"><span class="item" title="创建时间：2018-10-21 02:08:37"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2018-10-21T02:08:37+08:00">2018-10-21</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.9k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>8 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Garden Hamster</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciryrr3rj20zk0m8nhk.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E8%BD%AC%E8%BD%BD/" itemprop="item" rel="index" title="分类于 转载"><span itemprop="name">转载</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2018/10/21/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AD%E5%8C%85/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="一只脱离高级趣味的猪"><meta itemprop="description" content="Stay Hungry, Stay Foolish, zlk的个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="zlkBlog"></span><div class="body md" itemprop="articleBody"><blockquote><p>原文: <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL2RhaWx5anMvaS1uZXZlci11bmRlcnN0b29kLWphdmFzY3JpcHQtY2xvc3VyZXMtOTY2MzcwMzM2OGU4">I never understood JavaScript closures</span><br>作者: <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BvZGVtZXVsZGVyP3NvdXJjZT1wb3N0X2hlYWRlcl9sb2NrdXA=">Olivier De Meulder</span><br>时间: Sep 7, 2017<br>译注：作者从 JavaScript 的原理出发，详细解读执行过程，通过 “背包” 的形象比喻，来解释闭包。</p></blockquote><blockquote><p>转自<span class="exturl" data-url="aHR0cHM6Ly90b3V0aWFvLmlvLw==">开发者头条</span></p><p>作者:<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmhoa2luZy5jbi8yMDE4LzA5LzA4L2ktbmV2ZXItdW5kZXJzdG9vZC1qYXZhc2NyaXB0LWNsb3N1cmVzLw==">hhking</span></p></blockquote><p><strong>我从没理解过 JavaScript 闭包</strong><br><strong>直到有人这样跟我解释……</strong></p><p>正如标题所说，JavaScript 闭包对我来说一直是个迷。我 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uZnJlZWNvZGVjYW1wLm9yZy9sZXRzLWxlYXJuLWphdmFzY3JpcHQtY2xvc3VyZXMtNjZmZWI0NGY2YTQ0">看过</span> <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uZnJlZWNvZGVjYW1wLm9yZy93aGF0cy1hLWphdmFzY3JpcHQtY2xvc3VyZS1pbi1wbGFpbi1lbmdsaXNoLXBsZWFzZS02YTFmYzFkMmZmMWM=">很多</span> <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2xvc3VyZV8lMjhjb21wdXRlcl9wcm9ncmFtbWluZyUyOQ==">文章</span>，在工作中用过闭包，甚至有时候我都没有意识到我在使用闭包。</p><p>最近参加一个交流会，有人用某种方式向我解释了闭包，点醒了我。这篇文章我也将用这种方式来解释闭包。这里要称赞一下 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZXNtaXRoLmlvLw==">CodeSmith </span>的优秀人才和他们的《JavaScript The Hard Parts》系列。</p><span id="more"></span><h2 id="开始之前"><a class="anchor" href="#开始之前">#</a> 开始之前</h2><p>在理解闭包之前，一些重要的概念需要理解。其中一个就是 <strong>执行上下文（execution context）</strong>。</p><p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hhcmlmZi5jb20vYmxvZy93aGF0LWlzLXRoZS1leGVjdXRpb24tY29udGV4dC1pbi1qYXZhc2NyaXB0Lw==">这篇文章</span> 对执行上下文有很好的介绍。引用一下这篇文章：</p><blockquote><p>JavaScript 代码在执行时，它的执行环境非常重要，它会被处理成下面的某一种情况：</p><p><strong>全局代码 (Global code)</strong> —— 代码开始执行时的默认环境。</p><p><strong>函数代码 (Function code)</strong> —— 当执行到函数体时。</p><p>(…)</p><p>(…), 我们把术语 <code>执行上下文（execution context）</code> 称为当前执行代码所处的 <em>环境或者作用域</em>。</p></blockquote><p>换句话说，当我们开始执行程序时，首先处于全局上下文中。在全局上下文中声明的变量，称为全局变量。当程序调用函数时，会发生什么？发生下面这几步：</p><ol><li>JavaScript 创建一个新的执行上下文 —— 局部执行上下文。</li><li>这个局部执行上下文有属于它的变量集，这些变量是这个执行上下文的局部变量。</li><li>这个新的执行上下文被压入执行栈中。将执行栈当成是用来跟踪程序执行位置的一种机制。</li></ol><p>函数什么时候执行完？当遇到 <code>return</code> 语句或者结束括号 <code>&#125;</code> 时。函数结束时，发生下面情况：</p><ol><li>局部执行上下文从执行栈弹出。</li><li>函数把返回值返回到调用上下文。调用上下文是指调用该函数的的执行上下文，它可以是全局执行上下文也可以是另外一个局部执行上下文。这里的返回值怎么处理取决于调用执行上下文。返回值可是 <code>object</code> , <code>array</code> , <code>function</code> , <code>boolean</code> 等任何类型。如果函数没有 <code>return</code> 语句，那么返回值是 <code>undefined</code> 。</li><li>局部执行上下文被销毁。这点很重要 —— 被销毁。所有在局部执行上下文中声明的变量都被清除。这些变量不再可用。这也是为什么称它们为局部变量。</li></ol><h2 id="一个非常简单的例子"><a class="anchor" href="#一个非常简单的例子">#</a> 一个非常简单的例子</h2><p>在开始学习闭包之前，我们先来看下下面这段代码。它看起来很简单，所有的读者应该都能清楚的知道它的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="number">2</span>: <span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;</span><br><span class="line"><span class="number">3</span>:   <span class="keyword">let</span> ret = x + <span class="number">2</span></span><br><span class="line"><span class="number">4</span>:   <span class="keyword">return</span> ret</span><br><span class="line"><span class="number">5</span>: &#125;</span><br><span class="line"><span class="number">6</span>: <span class="keyword">let</span> b = <span class="title function_">addTwo</span>(a)</span><br><span class="line"><span class="number">7</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><p>为了理解 JavaScript 引擎的真正工作原理，我们来详细解释一下。</p><ol><li>在代码第一行，我们在全局执行上下文声明了一个新的变量 <code>a</code> ，并赋值为 <code>3</code> 。</li><li>接下来比较棘手了。第 2 到第 5 行属于一个整体。这里发生了什么呢？我们在全局执行上下文声明了一个变量，命名为 <code>addTwo</code> 。然后我们怎么对它赋值的？通过函数定义。所有在两个括号 <code>&#123;&#125;</code> 之间的内容都被赋给 <code>addTwo</code> 。函数里的代码不计算、不执行，只是保存在变量，留着后面使用。</li><li>现在我们到了第 6 行。看似很简单，其实这里有很多需要解读。首先我们在全局执行上下文声明了一个变量，标记为 <code>b</code> 。当变量刚声明时，它的默认值是 <code>undefined</code> 。</li><li>接着，还是在第 6 行，我们看到有个赋值运算符。我们准备给变量 <code>b</code> 赋新值。接着看到一个将要被调用的函数。当你看到变量后面跟着圆括号 <code>(...)</code> ，那就是函数调用的标识。提前说下后面的情况：每个函数都有返回值（一个值、一个对象或者是 <code>undefined</code> ）。函数的返回值将被赋值给变量 <code>b</code> 。</li><li>但是（在赋值前）我们首先要调用函数 <code>addTwo</code> 。JavaScript 将在全局执行上下文内存中查找变量 <code>addTwo</code> 。找到了！它在第 2 步（第 2-5 行）中定义，你瞧，变量 <code>addTwo</code> 包含函数定义。注意，变量 <code>a</code> 当做参数传给了函数。JavaScript 在全局执行上下文内存中寻找变量 <code>a</code> ，找到并发现它的值是 <code>3</code> ，然后把数值 <code>3</code> 做为参数传给函数。函数执行准备就绪。</li><li>现在执行上下文将会切换。一个新的局部执行上下文被创建，我们把它命名为 “addTwo 执行上下文”。该执行上下文被压入调用栈。在局部执行上下文中首先做些什么事呢？</li><li>你可能会想说：“在局部执行上下文中声明一个新的变量 <code>ret</code> ”。然后答案不是这样。正确答案是：我们首先需要查看函数的参数：在局部执行上下文中声明新的变量 <code>x</code> ，因为值 <code>3</code> 作为参数传给函数，所以变量 <code>x</code> 赋值为数值 <code>3</code> 。</li><li>下一步：局部执行上下文中声明新变量 <code>ret</code> 。它的值默认为 <code>undefined</code> 。（第 3 行）</li><li>还是第 3 行，准备执行加法。我们首先需要获取 <code>x</code> 的值。JavaScript 将寻找变量 <code>x</code> 。首先在局部执行上下文中寻找。找到变量 <code>x</code> 的值为 <code>3</code> 。第二个操作数是数值 <code>2</code> ，加法的结果（ <code>5</code> ）赋值给变量 <code>ret</code> 。</li><li>第 4 行。我们返回变量 <code>ret</code> 的值。在局部执行上下文中又进行查找 <code>ret</code> 。 <code>ret</code> 的值为 <code>5</code> 。所以该函数返回数值 <code>5</code> ，函数结束。</li><li>第 4-5 行。函数结束。局部执行上下文被销毁。变量 <code>x</code> 和 <code>ret</code> 被清除，不再存在。调用栈弹出该上下文，返回值返回给调用上下文。在这个例子中，调用上下文是全局执行上下文，因为函数 <code>addTwo</code> 是在全局执行上下文中调用的。</li><li>现在回到我们在第 4 步遗留的内容。返回值（数值 <code>5</code> ）复制给变量 <code>b</code> 。在这个小程序中，我们还在第 6 行。</li><li>下面我不再详细说明了。在第 7 行，变量 <code>b</code> 的值在 <code>console</code> 中打印出来。在我们的例子里将打印出数值 <code>5</code> 。</li></ol><p>对一个简单的程序，这真是个冗长的解释！而且我们甚至还没涉及到闭包。我保证一定会讲解闭包的。但是我们还是需求绕一两次。</p><h2 id="词法作用域-lexical-scope"><a class="anchor" href="#词法作用域-lexical-scope">#</a> 词法作用域 (Lexical scope)</h2><p>我们需要理解词法作用域的一些知识点。看看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="keyword">let</span> val1 = <span class="number">2</span></span><br><span class="line"><span class="number">2</span>: <span class="keyword">function</span> <span class="title function_">multiplyThis</span>(<span class="params">n</span>) &#123;</span><br><span class="line"><span class="number">3</span>:   <span class="keyword">let</span> ret = n * val1</span><br><span class="line"><span class="number">4</span>:   <span class="keyword">return</span> ret</span><br><span class="line"><span class="number">5</span>: &#125;</span><br><span class="line"><span class="number">6</span>: <span class="keyword">let</span> multiplied = <span class="title function_">multiplyThis</span>(<span class="number">6</span>)</span><br><span class="line"><span class="number">7</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example of scope:&#x27;</span>, multiplied)</span><br></pre></td></tr></table></figure><p>例子中，在局部执行上下文和全局执行上下文各有一些变量。JavaScript 的一个难点是如何寻找变量。如果在局部执行上下文没找到某个变量，那么到它的调用上下文中去找。如果在它的调用上下文也没找到，重复上面的查找步骤，直到在全局执行上下文中找（如果也没找到，那么就是 <code>undefined</code> ）。按照上面的例子来说明，它会验证这点。如果你理解作用域的原理，你可以跳过这部分。</p><ol><li>在全局执行上下文声明一个新变量 <code>val1</code> ，并赋值为数值 <code>2</code> 。</li><li>第 2-5 行声明新变量 <code>multiplyThis</code> 并赋值为函数定义。</li><li>第 6 行，在全局执行上下文声明新变量 <code>multiplied</code> 。</li><li>在全局执行上下文内存中获取变量 <code>multiplyThis</code> 并作为函数执行。传入参数数值 <code>6</code> 。</li><li>新函数调用 = 新的执行上下文：创建新的局部执行上下文。</li><li>在局部执行上下文中，声明变量 <code>n</code> 并赋值为数值 <code>6</code> 。</li><li>第 3 行，在局部执行上下文中声明变量 <code>ret</code> 。</li><li>还是第 3 行，两个操作数 —— 变量 <code>n</code> 和 <code>val1</code> 的值执行乘法运算。先在局部执行上下文查找变量 <code>n</code> ，它是我们在第 6 步中声明的，值为数值 <code>6</code> 。接着在局部执行上下文查找变量 <code>val1</code> ，在局部执行上下文没有找到名为 <code>val1</code> 的变量，所以我们检查调用上下文中。这里调用上下文是全局执行上下文。我们在全局执行上下文中找到它，它在第 1 步中被定义，值为数值 <code>2</code> 。</li><li>依旧是第 3 行。两个操作数相乘然后赋值给变量 <code>ret</code> 。6 * 2 = 12。 <code>ret</code> 现在值为 <code>12</code> 。</li><li>返回变量 <code>ret</code> 。局部执行上下文以及相应的变量 <code>ret</code> 和 <code>n</code> 一起被销毁。变量 <code>val1</code> 作为全局执行上下文的一部分没有被销毁。</li><li>回到第 6 行。在调用上下文中，变量 <code>multiplied</code> 被赋值为数值 <code>12</code> 。</li><li>最后在第 7 行，我们在 console 中显示变量 <code>multiplied</code> 的值。</li></ol><p>在这个例子中，我们需要记住，函数可以访问到它调用上下文中定义的变量。这种现象正式学名是 <strong>词法作用域</strong>。</p><blockquote><p>（译者注：觉得这里对词法作用域的解释限于此例，并不完全准确。词法作用域，函数的作用域是在函数定义的时候决定的，而不是调用时）。</p></blockquote><h2 id="返回值是函数的函数"><a class="anchor" href="#返回值是函数的函数">#</a> 返回值是函数的函数</h2><p>在第一个例子里函数 <code>addTwo</code> 返回的是个数值。记得之前提过函数可以返回任何类型。我们来看个函数返回函数的例子，这个是理解闭包的关键点。下面是我们要分析的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">let</span> val = <span class="number">7</span></span><br><span class="line"> <span class="number">2</span>: <span class="keyword">function</span> <span class="title function_">createAdder</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="number">3</span>:   <span class="keyword">function</span> <span class="title function_">addNumbers</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="number">4</span>:     <span class="keyword">let</span> ret = a + b</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">return</span> ret</span><br><span class="line"> <span class="number">6</span>:   &#125;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">return</span> addNumbers</span><br><span class="line"> <span class="number">8</span>: &#125;</span><br><span class="line"> <span class="number">9</span>: <span class="keyword">let</span> adder = <span class="title function_">createAdder</span>()</span><br><span class="line"><span class="number">10</span>: <span class="keyword">let</span> sum = <span class="title function_">adder</span>(val, <span class="number">8</span>)</span><br><span class="line"><span class="number">11</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example of function returning a function: &#x27;</span>, sum)</span><br></pre></td></tr></table></figure><p>我们来一步一步分解：</p><ol><li>第 1 行，我们在全局执行上下文声明变量 <code>val</code> 并赋值为数值 <code>7</code> 。</li><li>第 2-8 行，我们在全局执行上下文声明变量 <code>createAdder</code> 并赋值为函数定义。第 3-7 行表示函数定义。和前面所说，这时候不会进入函数，我们只是把函数定义保存在变量 (createAdder)。</li><li>第 9 行，我们在全局执行上下文声明名为 <code>adder</code> 的新变量，暂时赋值为 <code>undefined</code> 。</li><li>还是第 9 行，我们看到有括号 <code>()</code> ，知道需要执行或者调用函数。我们从全局执行上下文的内存中查找变量 <code>createAdder</code> ，它在第 2 步创建。ok，现在调用它。</li><li>调用函数，我们现在处于第 2 行。新的局部执行上下文被创建。我们可以在新的执行上下文中创建局部变量。JavaScript 引擎把新的上下文压入调用栈。该函数没有参数，我们直接进入函数体。</li><li>还是在 3-6 行。我们声明了个新函数。我们在局部执行上下文中创建了新的变量 <code>addNumbers</code> ，这点很重要， <code>addNumbers</code> 只在局部执行上下文中出现。我们使用局部变量 <code>addNumbers</code> 保存了函数定义。</li><li>现在到了第 7 行。我们返回变量 <code>addNumbers</code> 的值。JavaScript 引擎找到 <code>addNumbers</code> 这个变量，它是个函数定义。这没问题，函数可以返回任意类型，包括函数定义。所以我们返回了 <code>addNumbers</code> 这个函数定义。括号中的所有内容 —— 第 4-5 行组成了函数定义。我们也从调用栈中移除了该局部执行上下文。</li><li>局部执行上下文在返回时销毁了。 <code>addNumbers</code> 变量不存在了，但是函数定义还在，它被函数返回并赋值给了变量 <code>adder</code> —— 我们在第 3 步创建的变量。</li><li>现在到了第 10 行。我们在全局执行上下文中定义了新变量 <code>sum</code> ，暂时赋值是 <code>undefined</code> 。</li><li>接下来需要需要执行函数。函数定义在变量 <code>adder</code> 中。我们在全局执行上下文中查找并确保找到了它。这个函数带有两个参数。</li><li>我们获取这两个参数，以便能调用函数并传入正确的参数。第一个参数是变量 <code>val</code> ，在第 1 步中定义，表示数值 <code>7</code> , 第二个参数是数值 <code>8</code> 。</li><li>现在我们开始执行函数。该函数在定义在 3-5 行。新的局部执行上下文被创建，同时创建了两个新变量： <code>a</code> 和 <code>b</code> ，他们分别赋值为 <code>7</code> 和 <code>8</code> ，这是上一步提到的传给函数的参数。</li><li>第 4 行，声明变量 <code>ret</code> 。它是在局部执行上下文中声明的。</li><li>第 4 行，进行加法运算：我们让变量 <code>a</code> 和变量 <code>b</code> 的值相加。相加的结果（15）赋值给变量 <code>ret</code> 。</li><li>函数返回变量 <code>ret</code> 。局部执行上下文销毁，从调用栈中移除，变量 <code>a</code> 、 <code>b</code> 和 <code>ret</code> 都不存在了。</li><li>返回值赋值给在第 9 步定义的变量 <code>sum</code> 。</li><li>在 console 中打印 <code>sum</code> 的值。</li></ol><p>正如所预期的，console 打印出 15，但是这个过程我们真的经历了很多困难。我想在这里说明几点。首先，函数定义可以保存在变量中，函数定义在执行前对程序是不可见的；第二点，每次函数调用，都会创建一个局部执行上下文（临时的），局部执行上下文在函数结束后消失，函数在遇到 <code>return</code> 语句或者右括号 <code>&#125;</code> 时结束。</p><h2 id="最后闭包"><a class="anchor" href="#最后闭包">#</a> 最后，闭包</h2><p>看看下面的代码，会发生什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>:   <span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="number">4</span>:     counter = counter + <span class="number">1</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">return</span> counter</span><br><span class="line"> <span class="number">6</span>:   &#125;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">return</span> myFunction</span><br><span class="line"> <span class="number">8</span>: &#125;</span><br><span class="line"> <span class="number">9</span>: <span class="keyword">const</span> increment = <span class="title function_">createCounter</span>()</span><br><span class="line"><span class="number">10</span>: <span class="keyword">const</span> c1 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">11</span>: <span class="keyword">const</span> c2 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">12</span>: <span class="keyword">const</span> c3 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">13</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example increment&#x27;</span>, c1, c2, c3)</span><br></pre></td></tr></table></figure><p>通过之前的两个例子，我们应该掌握了其中的窍门，让我们按我们期望的执行方式来快速过一遍执行过程。</p><ol><li>1-8 行。我们在全局执行上下文创建了变量 <code>createCounter</code> 并赋值为函数定义。</li><li>第 9 行。在全局执行上下文声明变量 <code>increment</code> 。</li><li>还是第 9 行。我们需要调用函数 <code>createCounter</code> 并把它的返回值赋值给变量 <code>increment</code> 。</li><li>1-8 行，函数调用，创建新的局部执行上下文。</li><li>第 2 行，在局部执行上下文中声明变量 <code>counter</code> ，并赋值为数值 <code>0</code> 。</li><li>3-6 行，声明名为 <code>myFunction</code> 的变量。该变量是在局部执行上下文声明的。变量的内容是另一个函数定义 —— 在 4-5 行定义。</li><li>第 7 行，返回变量 <code>myFunction</code> 的值。局部执行上下文被删除了， <code>myFunction</code> 和 <code>counter</code> 也不存在了。程序控制权回到调用上下文。</li><li>第 9 行。在调用上下文，也是全局执行上下文中， <code>createCounter</code> 的返回值赋给 <code>increment</code> 。现在变量 <code>increment</code> 包含一个函数定义。该函数定义是 <code>createCounter</code> 返回的。它不再是标记为 <code>myFunction</code> ，但是是同一个函数定义。在全局执行上下文中，它被命名为 <code>increment</code> 。</li><li>第 10 行，声明变量 <code>c1</code> 。</li><li>继续第 10 行，寻找变量 <code>increment</code> ，它是个函数，调用函数。它包含之前返回的函数定义 —— 在 4-5 行定义的。</li><li>创建新的执行上下文，这里没有参数，开始执行函数。</li><li>第 4 行， <code>counter = counter + 1</code> 。在局部执行上下文寻找 <code>counter</code> 的值。我们只是创建了上下文而没有声明任何局部变量。我们看看全局执行上下文，也没有变量 <code>counter</code> 。JavaScript 会把这个转化成 <code>counter = undefined + 1</code> ，声明新的局部变量 <code>counter</code> 并赋值为数值 <code>1</code> ，因为 <code>undefined</code> 会转化成 <code>0</code> 。</li><li>第 5 行，我们返回 <code>counter</code> 的值，或者说数值 <code>1</code> 。销毁局部执行上下文和变量 <code>counter</code> 。</li><li>回到第 10 行，返回值（ <code>1</code> ）赋给 <code>c1</code> 。</li><li>第 11 行，重复第 10-14 的步骤，最后 <code>c2</code> 也赋值为 <code>1</code> 。</li><li>第 12 行，重复第 10-14 的步骤，最后 <code>c3</code> 也赋值为 <code>1</code> 。</li><li>第 13 行，我们打印出变量 <code>c1</code> 、 <code>c2</code> 和 <code>c3</code> 的值。</li></ol><p>自己尝试一下这个，看看会发生什么。你会发现，打印出来的并不是上面解释的预期结果 <code>1</code> 、 <code>1</code> 和 <code>1</code> ，而是打印出 <code>1</code> 、 <code>2</code> 和 <code>3</code> 。所以发生了什么？</p><p>不知道为什么， <code>increment</code> 函数记住了 <code>counter</code> 的值。这是怎么实现的呢？</p><p>是不是因为 <code>counter</code> 是属于全局执行上下文？试试 <code>console.log(counter)</code> ，你会得到 <code>undefined</code> 。所以它并不是。</p><p>或许，是因为当你调用 <code>increment</code> 时，它以某种方式返回创建它的函数（createCounter）的地方？这是怎么回事呢？变量 <code>increment</code> 包含函数定义，而不是它从哪里创建。所以并不是这个原因。</p><p>所以这里肯定存在另一种机制。它就是<strong>闭包</strong>。我们终于讲到它了，一直缺失的部分。</p><p>下面是它的工作原理。只要你声明一个新的函数并赋值给一个变量，你就保存了这个函数定义，<strong>也就形成了闭包</strong>。闭包包含函数创建时的作用域里的所有变量。这类似于一个背包。函数定义带着一个背包，包里保存了所有在函数定义创建时作用域里的变量。</p><p>所以我们上面的解释全错了。我们重新来一遍，这次是正确的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="number">2</span>:   <span class="keyword">let</span> counter = <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>:   <span class="keyword">const</span> myFunction = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="number">4</span>:     counter = counter + <span class="number">1</span></span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">return</span> counter</span><br><span class="line"> <span class="number">6</span>:   &#125;</span><br><span class="line"> <span class="number">7</span>:   <span class="keyword">return</span> myFunction</span><br><span class="line"> <span class="number">8</span>: &#125;</span><br><span class="line"> <span class="number">9</span>: <span class="keyword">const</span> increment = <span class="title function_">createCounter</span>()</span><br><span class="line"><span class="number">10</span>: <span class="keyword">const</span> c1 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">11</span>: <span class="keyword">const</span> c2 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">12</span>: <span class="keyword">const</span> c3 = <span class="title function_">increment</span>()</span><br><span class="line"><span class="number">13</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example increment&#x27;</span>, c1, c2, c3)</span><br></pre></td></tr></table></figure><ol><li>1-8 行。我们在全局执行上下文创建了变量 <code>createCounter</code> 并赋值为函数定义。同上。</li><li>第 9 行。在全局执行上下文声明变量 <code>increment</code> 。同上。</li><li>还是第 9 行。我们需要调用函数 <code>createCounter</code> 并把它的返回值赋值给变量 <code>increment</code> 。同上。</li><li>1-8 行，函数调用，创建新的局部执行上下文。同上。</li><li>第 2 行，在局部执行上下文中声明变量 <code>counter</code> ，并赋值为数值 <code>0</code> 。同上。</li><li>3-6 行，声明名为 <code>myFunction</code> 的变量。该变量是在局部执行上下文声明的。变量的内容是另一个函数定义 —— 在 4-5 行定义。现在我们同时 <em>创建了一个闭包</em> 并把它作为函数定义的一部分。闭包包含了当前作用域里的变量，在这里是变量 <code>counter</code> (值为 <code>0</code> )。</li><li>第 7 行，返回变量 <code>myFunction</code> 的值。局部执行上下文被删除了， <code>myFunction</code> 和 <code>counter</code> 也不存在了。程序控制权回到调用上下文。所以我们返回了函数定义和它的 <em>闭包</em> —— 这个背包包含了函数创建时作用域里的变量。</li><li>第 9 行。在调用上下文，也是全局执行上下文中， <code>createCounter</code> 的返回值赋给 <code>increment</code> 。现在变量 <code>increment</code> 包含一个函数定义（和闭包）。该函数定义是 <code>createCounter</code> 返回的。它不再是标记为 <code>myFunction</code> ，但是是同一个函数定义。在全局执行上下文中，它被命名为 <code>increment</code> 。</li><li>第 10 行，声明变量 <code>c1</code> 。</li><li>继续第 10 行，寻找变量 <code>increment</code> ，它是个函数，调用函数。它包含之前返回的函数定义 —— 在 4-5 行定义的。（同时它也有个包含变量的背包）</li><li>创建新的执行上下文，这里没有参数，开始执行函数。</li><li>第 4 行， <code>counter = counter + 1</code> 。我们需要寻找变量 <code>counter</code> 。我们在局部或者全局执行上下文寻找前，先查看我们的背包。我们检查闭包。你瞧！闭包里包含变量 <code>counter</code> ，值为 <code>0</code> 。通过第 4 行的表达式，它的值设为 <code>1</code> 。它继续保存在背包里。现在闭包包含值为 <code>1</code> 的变量 <code>counter</code> 。</li><li>第 5 行，我们返回 <code>counter</code> 的值，或者说数值 <code>1</code> 。销毁局部执行上下文和变量 <code>counter</code> 。</li><li>回到第 10 行，返回值（ <code>1</code> ）赋给 <code>c1</code> 。</li><li>第 11 行，重复第 10-14 的步骤。这次，当我们查看闭包时，我们看到变量 <code>counter</code> 的值为 <code>1</code> 。它是在第 12 步（程序第 4 行）设置的。通过 <code>increment</code> 函数，它的值增加并保存为 <code>2</code> 。 最后 <code>c2</code> 也赋值为 <code>2</code> 。</li><li>第 12 行，重复第 10-14 的步骤，最后 <code>c3</code> 也赋值为 <code>3</code> 。</li><li>第 13 行，我们打印出变量 <code>c1</code> 、 <code>c2</code> 和 <code>c3</code> 的值。</li></ol><p>现在我们理解它的原理了。需要记住的关键点是，但函数声明时，它包含函数定义和一个闭包。<strong>闭包是函数创建时作用域内所有变量的集合。</strong></p><p>你可能会问，是不是所有函数都有闭包，即使是在全局作用域下创建的函数？答案是肯定的。全局作用域下创建的函数也生成闭包。但是既然函数是在全局作用域下创建的，他们可以访问全局作用域下的所有变量。所以这和闭包的概念不相关。</p><p>当函数的返回值是一个函数时，闭包的概念就变得更加相关了。返回的函数可以访问不在全局作用域里的变量，但它们只存在于闭包里。</p><h2 id="并不简单的闭包"><a class="anchor" href="#并不简单的闭包">#</a> 并不简单的闭包</h2><p>有时候，你可能都没有注意到闭包的生成。你可能在偏函数应用看到过例子，像下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="number">4</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addX</span> = x =&gt; <span class="function"><span class="params">n</span> =&gt;</span> n + x</span><br><span class="line"><span class="keyword">const</span> addThree = <span class="title function_">addX</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> d = <span class="title function_">addThree</span>(c)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;example partial application&#x27;</span>, d)</span><br></pre></td></tr></table></figure><p>如果箭头函数让你难以理解，下面是等价的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let c = 4</span><br><span class="line">function addX(x) &#123;</span><br><span class="line">  return function(n) &#123;</span><br><span class="line">     return n + x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const addThree = addX(3)</span><br><span class="line">let d = addThree(c)</span><br><span class="line">console.log(&#x27;example partial application&#x27;, d)</span><br></pre></td></tr></table></figure><p>我们声明了一个通用的相加函数 <code>addX</code> ：传入一个参数（ <code>x</code> ）然后返回另一个函数。</p><p>返回的函数也带有一个参数，这个参数和变量 <code>x</code> 相加。</p><p>变量 <code>x</code> 是闭包的一部分。当变量 <code>addThree</code> 在局部上下文中声明时，被赋值为函数定义和闭包。该闭包包含变量 <code>x</code> 。</p><p>所以现在调用执行 <code>addThree</code> 是，它可以从闭包中获取变量 <code>x</code> ，而变量 <code>n</code> 是通过参数传入，所以函数可以返回相加的和。</p><p>这个例子 console 会打印出数值 <code>7</code> 。</p><h2 id="结论"><a class="anchor" href="#结论">#</a> 结论</h2><p>我牢牢记住闭包的方法是通过 <strong>背包的比喻</strong> 。当一个函数被创建、传递或者从另一个函数中返回时，它就背着一个背包。背包里是函数声明时的作用域里的所有变量</p><div class="tags"><a href="/tags/JavaScript/" rel="tag"><i class="ic i-tag"></i> JavaScript</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2019-03-15 01:14:06" itemprop="dateModified" datetime="2019-03-15T01:14:06+08:00">2019-03-15</time> </span><span id="2018/10/21/我所理解的闭包/" class="item leancloud_visitors" data-flag-title="我所理解的闭包" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>一只脱离高级趣味的猪 <i class="ic i-at"><em>@</em></i>zlkBlog</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2018/10/21/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AD%E5%8C%85/" title="我所理解的闭包">http://example.com/2018/10/21/我所理解的闭包/</a></li><li class="license"><strong>版权声明： </strong><span class="red">本页内容禁止转载！</span></li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/2018/10/25/%E5%B1%85%E4%B8%AD/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey0a334j20zk0m8qpt.jpg" title="css居中问题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 面试</span><h3>css居中问题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D"><span class="toc-number">1.</span> <span class="toc-text">开始之前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">2.</span> <span class="toc-text">一个非常简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-lexical-scope"><span class="toc-number">3.</span> <span class="toc-text">词法作用域 (Lexical scope)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">返回值是函数的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E9%97%AD%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">最后，闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E4%B8%8D%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">6.</span> <span class="toc-text">并不简单的闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">7.</span> <span class="toc-text">结论</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2018/10/21/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AD%E5%8C%85/" rel="bookmark" title="我所理解的闭包">我所理解的闭包</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="一只脱离高级趣味的猪" data-src="/images/avatar.jpg"><p class="name" itemprop="name">一只脱离高级趣味的猪</p><div class="description" itemprop="description">zlk的个人博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">8</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">6</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dhcmRlbkhhbXN0ZXI=" title="https:&#x2F;&#x2F;github.com&#x2F;GardenHamster"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>文章</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/VUE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="分类于 VUE框架学习">VUE框架学习</a></div><span><a href="/2019/02/12/Vue%E5%9F%BA%E7%A1%80-day05/" title="vue基础(5)">vue基础(5)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/VUE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="分类于 VUE框架学习">VUE框架学习</a></div><span><a href="/2019/02/07/Vue%E5%9F%BA%E7%A1%80-day04/" title="vue基础(4)">vue基础(4)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/VUE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="分类于 VUE框架学习">VUE框架学习</a></div><span><a href="/2019/01/31/Vue%E5%9F%BA%E7%A1%80-day02/" title="vue基础(2)">vue基础(2)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ES6%E6%96%B0%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="分类于 ES6新增加的数据类型">ES6新增加的数据类型</a></div><span><a href="/2018/11/08/ES6%E7%9A%84Set%E5%92%8CMap/" title="ES6的Set和Map">ES6的Set和Map</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ES6%E4%B8%AD%E7%9A%84%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7/" title="分类于 ES6中的拓展运算符号">ES6中的拓展运算符号</a></div><span><a href="/2018/11/08/ES6%E4%B9%8B%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/" title="ES6之拓展运算符">ES6之拓展运算符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/VUE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="分类于 VUE框架学习">VUE框架学习</a></div><span><a href="/2019/02/01/Vue%E5%9F%BA%E7%A1%80-day03/" title="vue基础(3)">vue基础(3)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%BD%AC%E8%BD%BD/" title="分类于 转载">转载</a></div><span><a href="/2018/10/21/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E9%97%AD%E5%8C%85/" title="我所理解的闭包">我所理解的闭包</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/02/%E6%B5%8B%E8%AF%95123/" title="测试123">测试123</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%9D%A2%E8%AF%95/" title="分类于 面试">面试</a></div><span><a href="/2018/10/25/%E5%B1%85%E4%B8%AD/" title="css居中问题">css居中问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/VUE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="分类于 VUE框架学习">VUE框架学习</a></div><span><a href="/2019/01/30/Vue%E5%9F%BA%E7%A1%80-day01/" title="vue基础(1)">vue基础(1)</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-garden hamster"></i> </span><span class="author" itemprop="copyrightHolder">一只脱离高级趣味的猪 @ Garden Hamster</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">72k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:05</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2018/10/21/我所理解的闭包/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,nocopy:!0,copyright:"复制失败，本页内容禁止转载！",ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>